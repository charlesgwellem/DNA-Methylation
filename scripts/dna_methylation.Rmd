---
title: "dna_methylation"
author: "Charles"
date: "Last compiled on `r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    theme: cosmo
    highlight: monochrome
    toc: yes
    toc_float: no
    toc_depth: 6
    code_folding: hide
  word_document:
    toc: yes
    toc_depth: '6'
  pdf_document:
    toc: yes
    toc_depth: '6'
editor_options:
  chunk_output_type: console
---

```{css, echo=FALSE}
<style>
body, h1, h2, h3, h4 {
    font-family: "Bookman", serif;
}

body {
    color: #333333;
}
a, a:hover {
    color: red;
}
pre {
    font-size: 10px;
}
</style>
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

## Introduction

Epigenetic mechanisms regulate gene expression. Certain technologies enable us measure some epigentic endpoints. One example is DNA methylation. DNA methylation is a chemical process that occurs around genes and which is capable of silencing gene expression. In this project, I will analyse DNA methylation data for the whole genome and relate it to phenotypic variation.

It has been studies that when part of a genome is methylated, the gene close to it is not expressed. It is inherited at mitosis.

Methylation often occurs at CpG islands. A **CpG** is a C, followed by a G but from the $5^1$ end to the $3^1$ end. When one DNA strand is methylated, so is the other. if we also have a CpG on one strand, we have it as well on the other strand.When DNA replicates, its methylation characteristics are preserved.

In this project I will be performing exploratory data analysis on public DNA methylation data.

## Load libraries

```{r}
library(BSgenome.Hsapiens.UCSC.hg19) # human genome package
```

## Exploratory data analysis 

### Calculate GC content on chromosome 22.

The GC-content are the proportion of bases that are either "G" or "C".

#### Subset gene sequence of chr22

```{r}
# subset chr22
chr22 <- Hsapiens[["chr22"]]

# select start region
s <- subseq(chr22, 
            start = 23456789, 
            width = 1000)
print(as.character(s))
```

The string above is the DNA sequence 1000 basepairs centered around the point 23456789.

#### Calculate the GC content

```{r}

cg_prop <- letterFrequency(s, 
                letters = "CG", # specify string of interest
                as.prob = TRUE) # specify results output
cg_prop
```

The results show that GC content of the slected resion of chr22 is **58.3%**.

### Calculate the number of CpGs

```{r}
n_cg <- countPattern(s, 
                     pattern = "CG")
n_cg
```

There are 10 CpGs in the DNA string of interest on chr22.

### Calculate the number of GpCs

```{r}
n_gc <- countPattern(s, 
                     pattern = "GC")
n_gc
```

There are 65 GpCs in the DNA string of interest on chr22.

## CpG islands Assessment

CpG islands are regions of the DNA with higher concentrations of CpGs compared to other areas of the genome.

### Bioconductor AnnotationHub package

This package permits us to explore available annotations.

```{r}
library(AnnotationHub)
ah <- AnnotationHub()
head(ah)
```

### Subset these to just the databases related to the hg19 genome.

```{r}
ah <- subset(ah,ah$genome=="hg19")
head(ah)
```

The table above shows the databses with annotations related to the hg19 genome. 

### Query gene annotations

```{r}
query(ah, "genes")
```

### Identifing the record ID used by AnnotationHub for hg19 CpG Islands

```{r}
cgi_id <- query(ah,"cpg")
head(cgi_id)
```

The results show that the record ID used by AnnotationHub for hg19 CpG Islands is **AH5086**.

### Retrive annotations related to record ID AH5086

```{r}
cgi <- ah[["AH5086"]]
```

### Calculate the number of CpGs in cgi

```{r}
length(cgi)
```

There are `r length(cgi)` CpGs in the cgi object above.

### Extract sequences of each CpG islands

```{r}
library(BSgenome.Hsapiens.UCSC.hg19)

cgiseq <- getSeq(Hsapiens, cgi)
head(cgiseq)
```

The result above shows each of the `r length(cgi)` CpGs,  the width (number of nucleotides in each CpG island) and the actual sequences of each CpG.

### Computing the proportion of Cs for each island and the median.

```{r}
prop_c <- letterFrequency(cgiseq, # sequences of cpgs
                            letters = "C", # letter of interest
                            as.prob = TRUE) # return proportions
median(prop_c)
```

The results show that the median proportion of Cs in the CpG sequences is `r median(prop_c)`.

### Computing the proportion of Gs for each island and the median.

```{r}
prop_g <- letterFrequency(cgiseq, # sequences of cpgs
                            letters = "G", # letter of interest
                            as.prob = TRUE) # return proportions
median(prop_g)
```

The results show that the median proportion of Cs in the CpG sequences is `r median(prop_g)`.

### Calculate the median of observed number of CpGs by the expected number of CpGs.

```{r, fig.align='center'}
res <- alphabetFrequency(cgiseq)
L <- rowSums(res)
exp_cg <- L * prop_c * prop_g
obs_cg <- vcountPattern(pattern = "CG",
                   subject = cgiseq)
cpgoe <- obs_cg / exp_cg
median(cpgoe)

# we can look at a histogram
hist(cpgoe)
abline(v=1, col=2)

# because these are ratios, looking at the log is better
hist(log2(cpgoe))
abline(v=0, col=2)
```

The results show that the ratio of observed to expected cpgs is `r median(cpgoe)`. This shows that the expected number of CpGs is higher than the actually observed number of cpgs.

### Calculate the median of observed number of GpCs by the expected number of CpGs.

```{r, fig.align='center'}
obs_gc <- vcountPattern(pattern = "GC",
                   subject = cgiseq)
gpcoe <- obs_gc / exp_cg
median(gpcoe)

# we can look at a histogram
hist(gpcoe)
abline(v=1, col=2)

# because these are ratios, looking at the log is better
hist(log2(gpcoe))
abline(v=0, col=2)

### We can look at a histogram
boxplot(list(cpgoe,gpcoe))
```

The results show that the ratio of observed to expected cpgs is `r median(gpcoe)`. This shows that the expected number of GpCs is less than the actually observed number of gpcs.

### Analyse CpGs in regions that are not islands

To achieve this, we will shift the islands by 20000 nucleotides and restrict analysis to mapped chromosomes.

```{r}
chr2use <- seqlevels(cgi)[1:24]
index <- which(seqnames(cgi) %in% chr2use)

# define the non-cpg islands by shifting known ones by 20K nucleotides
noncgi <- shift(cgi[index], 20000)

# some of these regions contain repeats or are unmapped, so we remove regions that have 0 Cs or 0 Gs.

library(BSgenome.Hsapiens.UCSC.hg19)

noncgiseq <- getSeq(Hsapiens, noncgi)
nullres <- alphabetFrequency(noncgiseq)
keepIndex <- nullres[,"G"]>0 &  nullres[,"C"]>0 & nullres[,"N"]==0
nullres <- nullres[keepIndex, ]
noncgiseq <- noncgiseq[keepIndex]
```

### Analyse median of CpGs in regions that are not islands

```{r}
res <- alphabetFrequency(noncgiseq)
L <- rowSums(res)
prop_c <- res[, "C"] / L
prop_g <- res[, "G"] / L
expected_cg <- L * prop_c * prop_g
obs_cg <- vcountPattern(noncgiseq,
                        pattern = "CG")
cpgoe <- obs_cg / expected_cg
median(cpgoe)
```

The results show that the median of the ratio of the number of observed CpGs to the number of expected CpGs is `r median(cpgoe)`. This shows that in these regions the CpG-poor areas also have a small ratio of number of observed CpGs to number of expected CpGs.

## Statistical considerations

### Single CpG model

$Y_{ij} = \beta_{0,j} + X_i\beta_{1,j} + \epsilon_{ij}$

$Y_{ij}$ = Observed data
$\beta_{0,j}$ = baseline methylation level
$X_i$ = outcome of interest e.g. tumour and normal
$\beta_{1,j}$ = effect at j-th position
$\epsilon_{i,j}$ = measurement error

### Functional model

$Y_{ij} = \beta_0(l_j) + X_i\beta_1(l_j) + \epsilon_{ij}$

Where we now have parameters as a function of location.






## Session info

```{r}
# obtain the session info
sessionInfo()
```